---
title: 开发第一个小程序
date: 2025-03-06T15:21:12+08:00
updated: 2025-03-10T15:54:43+08:00
dg-publish: false
---

开发指南：<https://developers.weixin.qq.com/miniprogram/dev/framework/>

- 注册帐号
- 下载开发者工具

打开开发者工具，使用微信扫码登录，创建一个项目

## 扫盲

一个小程序页面由以下四种文件组成

- json 页面配置
- wxml 页面模板，描述页面结构
- wxss 页面样式
- js 脚本，所有的逻辑都通过 JS 执行

逻辑层：JS 脚本，视图层：WXML、WXS（类似 `script`）、WXSS

`app` 的都是公共文件，其他 `pages` 目录中的都是页面的

### JSON 静态配置文件

**JSON 文件**都是被包裹在一个大括号中 `{}`，通过 key-value 的方式来表达数据，每对值通过 `:` 连接，在小程序中进行静态配置

JSON 的值只能是以下几种数据格式：

1. 数字，包含浮点数和整数
2. 字符串，需要包裹在双引号中
3. Bool 值，`true` 或者 `false`
4. 数组，需要包裹在方括号中 `[]`
5. 对象，需要包裹在大括号中 `{}`
6. `null`

没有注释

在 `app.json` 中可以声明页面路径

```json
{
  "pages":[
    "pages/index/page", // 第一项默认为首页
    "pages/other/other"
  ]
}
```

需要手动指定默认首页可以

```json
{
  "entryPagePath": "pages/index/index"
}
```

定义小程序底部 tab

```json
{
  "tabBar": {
		"color": '#333',
		"selectedColor": "#B8E67B",
		"position": "top",
		"backgroundColor": "#fff",
		"borderStyle": "black",
    "list": [
      { "text": "Tab1", "pagePath": "pageA" },
      { "text": "Tab1", "pagePath": "pageF" },
      { "text": "Tab1", "pagePath": "pageG" }
    ]
  }
}
```

- position `top` 或 `bottom`，`top` 的时候不显示 icon
- custom `false`，`true` 的时候自定义 [自定义](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html)
- list 最少 2 个，最多 5 个
	- pagePath 页面路径
	- text 文字
	- iconPath 图片路径，大小限制 40kb，尺寸建议 81x81px
	- selectedIconPath 选中图片路径

设置全局状态栏、导航条、标题、窗口

```json
{
  "window": {
    "navigationBarBackgroundColor": "#ffffff",
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "微信接口功能演示",
    "backgroundColor": "#eeeeee",
    "backgroundTextStyle": "light"
  }
}
```

- navigationBarBackgroundColor 导航栏背景颜色
- navigationBarTextStyle 导航栏标题、状态栏颜色，仅支持 `black` / `white`
- navigationBarTitleText 导航栏标题文字内容
- navigationStyle 导航栏样式，仅支持以下值： `default` 默认样式、`custom` 自定义导航栏，只保留右上角胶囊按钮
- homeButton `false` | `true` 在非首页、非页面栈最底层页面或非 tabbar 内页面中的导航栏展示 home 键
- backgroundColor 窗口的背景色
- backgroundTextStyle 下拉 loading 的样式，仅支持 `dark` / `light`
- backgroundColorTop 顶部窗口的背景色，仅 iOS 支持
- backgroundColorBottom 底部窗口的背景色，仅 iOS 支持
- enablePullDownRefresh 是否开启全局的下拉刷新 [Page.onPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onpulldownrefresh)
- onReachBottomDistance 页面上拉触底事件触发时距页面底部距离，单位为 px [Page.onReachBottom](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onreachbottom)
- pageOrientation 屏幕旋转设置，支持 `auto` / `portrait` / `landscape` [响应显示区域变化](https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html)
- [restartStrategy](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#restartStrategy) 重新启动策略配置 `homePage` / `homePageAndLatestPage`
- initialRenderingCache 页面 [初始渲染缓存](https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html) 配置，支持 `static` / `dynamic`
- visualEffectInBackground 切入系统后台时，隐藏页面内容，保护用户隐私。支持 `hidden` / `none`
- handleWebviewPreload 控制 [预加载下个页面的时机](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_nav.html#_2-4-%E6%8E%A7%E5%88%B6%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%B8%8B%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA)。支持 `static` / `manual` / `auto`

启用插件功能页

```json
{
  "functionalPages": {
    "independent": true
  }
}
```

兼容旧版本

```json
{
  "functionalPages": true
}
```

声明小程序需要使用的 [插件](https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/using.html)。

```json
{
  "plugins": {
    "myPlugin": {
      "version": "1.0.0",
      "provider": "wxidxxxxxxxxxxxxxxxx"
    }
  }
}
```

申明需要后台运行的能力，类型为数组

```json
{
  "pages": ["pages/index/index"],
  "requiredBackgroundModes": ["audio", "location"]
}
```

使用以下 8 个地理位置相关接口时，需要声明该字段

```json
{
  "pages": ["pages/index/index"],
  "requiredPrivateInfos": [ 
    "getLocation",
    "onLocationChange",
    "startLocationUpdateBackground",
    "chooseAddress"
  ]
}
```

- [getFuzzyLocation](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getFuzzyLocation.html): 获取模糊地理位置
- [getLocation](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html): 获取精确地理位置
- [onLocationChange](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.onLocationChange.html): 监听实时地理位置变化事件
- [startLocationUpdate](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.startLocationUpdate.html): 接收位置消息（前台）
- [startLocationUpdateBackground](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.startLocationUpdateBackground.html): 接收位置消息（前后台）
- [chooseLocation](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.chooseLocation.html): 打开地图选择位置
- [choosePoi](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.choosePoi.html): 打开 POI 列表选择位置
- [chooseAddress](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/address/wx.chooseAddress.html): 获取用户地址信息

均需在小程序管理后台，[「开发」-「开发管理」-「接口设置」](https://mp.weixin.qq.com/wxamp/categoryapi/index?token=1033339147&lang=zh_CN) 中自助开通该接口权限

小程序 [接口权限](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html) 相关设置

```json
{
  "pages": ["pages/index/index"],
  "permission": {
    "scope.userLocation": {
      "desc": "你的位置信息将用于小程序位置接口的效果展示" // 高速公路行驶持续后台定位
    }
  }
}
```

启用适配暗黑模式

```json
{
  "darkmode": true,
	"themeLocation": "/path/to/theme.json"
}
```

**页面配置**会覆盖全局 window 中相同的配置

<https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html>

### 模板标记语法

**WXML** 全称是 WeiXin Markup Language，是小程序框架设计的一套标签语言，结合小程序的基础组件、事件系统，可以构建出页面的结构

以下使用了注释，容器、文字和图片标签

```wxml
<!-- view 中包含了 text 标签 -->
<view>
  <text>hello world</text>
  <image class="userinfo-avatar" src="./image/a.png" ></image>
</view>
```

JS 中声明的变量在模板中使用 `{{}}` 包裹，例如 JS 中有 `data: { time: (new Date()).toString(), test: '测试内容' }`，那么使用的时候，这样进行数据绑定，每次编译都会更新

```wxml
<text data-test="{{test}}">当前时间：{{time}}</text>
```

- 变量大小写敏感 `name` 和 `Name` 是两个不同的变量
- 没有被定义的变量的或者是被设置为 `undefined` 的变量不会被同步到 wxml 中
- `{{}}` 中可以进行简单的逻辑运算，例如 `a === 10 ? '10' : '不等于10'`，`a + b`，`"hello" + name`

双向绑定，输入的同时修改值

```wxml
<input model:value="{{value}}" />
```

使用指令

```wxml
<view wx:if="{{condition}}"> True </view>

<view wx:if="{{length > 5}}"> 1 </view>
<view wx:elif="{{length > 2}}"> 2 </view>
<view wx:else> 3 </view>

<!-- 次性判断多个组件标签，可以使用一个 <block/> 标签将多个组件包装起来 -->
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>


<!-- array 是一个数组 -->
<view wx:for="{{array}}">
  {{index}}: {{item.message}}
</view>

<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
  {{idx}}: {{itemName.message}}
</view>

<block wx:for="{{[1, 2, 3]}}">
  <view> {{index}}: </view>
  <view> {{item}} </view>
</block>

<switch wx:for="{{objectArray}}" wx:key="unique" > {{item.id}} </switch>
<button bindtap="switch"> Switch </button>
<button bindtap="addToFront"> Add to the front </button>

<switch wx:for="{{numberArray}}" wx:key="*this" > {{item}} </switch>
<button bindtap="addNumberToFront"> Add Number to the front </button>
```

- 使用 `wx:key` 来指定列表中项目的唯一的标识符

模板可以先声明，然后使用的时候加 is 属性

```wxml
<!-- msgItem.wxml -->
<template name="msgItem">
  <view>
    <text> {{index}}: {{msg}} </text>
    <text> Time: {{time}} </text>
  </view>
</template>

<template is="msgItem" data="{{...item}}"/>
```

可以在其他页面中引用

```wxml
<import src="msgItem.wxml"/>

<template is="msgItem" data="{{...item}}"/>
```

共同属性

所有 wxml 标签都支持的属性称之为共同属性

| **属性名**        | **类型**       | **描述**  | **注解**               |
| -------------- | ------------ | ------- | -------------------- |
| `id`           | String       | 组件的唯一标识 | 整个页面唯一               |
| `class`        | String       | 组件的样式类  | 在对应的 WXSS 中定义的样式类    |
| `style`        | String       | 组件的内联样式 | 可以动态设置的内联样式          |
| `hidden`       | Boolean      | 组件是否显示  | 所有组件默认显示             |
| `data-*`       | Any          | 自定义属性   | 组件上触发的事件时，会发送给事件处理函数 |
| `bind*/catch*` | EventHandler | 组件的事件   |                      |

### 样式文件

`rpx` 单位可以适配多设备

引用其他样式文件

```wxcc
@import url('./test_0.css')
```

或

```wxcss
@import './test_0.wxss'
```

区别是 `url` 的会多一次单独的请求

媒体查询

```wxss
.my-class {
  width: 40px;
}

@media (min-width: 480px) {
  /* 仅在 480px 或更宽的屏幕上生效的样式规则 */
  .my-class {
    width: 200px;
  }
}
```

内联样式即直接在模板的标签 style 属性上写的样式

```wxml
<!--内联样式-->
<view style="color: red; font-size: 48rpx"></view>

<!--可动态变化的内联样式-->
<!--
{
  eleColor: 'red',
  eleFontsize: '48rpx'
}
-->
<view style="color: {{eleColor}}; font-size: {{eleFontsize}}"></view>
```

选择器

| **类型** | **选择器**    | **样例**            | **样例描述**                            |
| ------ | ---------- | ----------------- | ----------------------------------- |
| 类选择器   | `.class`   | `.intro`          | 选择所有拥有 `class="intro"` 的组件          |
| id 选择器 | `#id`      | `#firstname`      | 选择拥有 `id="firstname"` 的组件           |
| 元素选择器  | `element`  | `view` `checkbox` | 选择所有文档的 `view` 组件和所有的 `checkbox` 组件 |
| 伪元素选择器 | `::after`  | `view::after`     | 在 `view` 组件后边插入内容                   |
| 伪元素选择器 | `::before` | `view::before`    | 在 view 组件前边插入内容                     |

权重：

1. `!important` 无限
2. `style=""` 内联样式 1000
3. `#id` 100
4. `.class` 10
5. `element` 元素选择器 1

官方样式库：<https://github.com/Tencent/weui-wxss>

### 脚本

小程序的 JS 包含三部分

- ECMAScript
- 小程序框架
- 小程序 API

小程序目前可以运行在三大平台：

1. iOS 平台，包括 iOS9、iOS10、iOS11
2. Android 平台
3. 小程序 IDE

模块化导出导入

```js
// moduleA.js
module.exports = function( value ){
  return value * 2;
}

// 在B.js中引用模块A
var multiplyBy2 = require('./moduleA')
var result = multiplyBy2(4)

// 引用公共代码
var common = require('common.js')
common.sayHello('MINA')
```

脚本执行顺序为：先执行 `app.js` 然后按次序执行 `pages` 中的页面脚本

获取节点

```js
const query = this.createSelectorQuery()
query.select('#the-id').boundingClientRect(function(res){
  res.top // #the-id 节点的上边界坐标（相对于显示区域）
})
query.selectViewport().scrollOffset(function(res){
  res.scrollTop // 显示区域的竖直滚动位置
})
query.exec()
```

节点布局相交状态

```js
Page({
  onLoad: function(){
    this.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
      res.id // 目标节点 id
      res.dataset // 目标节点 dataset
      res.intersectionRatio // 相交区域占目标节点的布局区域的比例
      res.intersectionRect // 相交区域
      res.intersectionRect.left // 相交区域的左边界坐标
      res.intersectionRect.top // 相交区域的上边界坐标
      res.intersectionRect.width // 相交区域的宽度
      res.intersectionRect.height // 相交区域的高度
    })
  }
})

Page({
  onLoad: function(){
    this.createIntersectionObserver({
      thresholds: [0.2, 0.5]
    }).relativeTo('.relative-class').relativeToViewport().observe('.target-class', (res) => {
      res.intersectionRatio // 相交区域占目标节点的布局区域的比例
      res.intersectionRect // 相交区域
      res.intersectionRect.left // 相交区域的左边界坐标
      res.intersectionRect.top // 相交区域的上边界坐标
      res.intersectionRect.width // 相交区域的宽度
      res.intersectionRect.height // 相交区域的高度
    })
  }
})
```

## 新增一个页面

需要在 `app.json` 的 `pages` 中声明，每新增一个页面都需要加到后面的数组中

```json
{
  "pages": [
    "pages/index/index",
  ],
  "window": {
    "backgroundColor": "#F6F6F6",
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#F6F6F6",
    "navigationBarTitleText": "云开发 QuickStart",
    "navigationBarTextStyle": "black"
  },
  "tabBar": {
    "color": "#A2A9B0",
    "selectedColor": "#07C160",
    "backgroundColor": "#ffffff",
    "list": [
      {
        "pagePath": "pages/index/index",
        "text": "快速开始",
        "iconPath": "images/icons/home.png",
        "selectedIconPath": "images/icons/home-active.png"
      },
    ]
  },
}
```

例如新增了 `pages/index/index`，那么创建 `pages/index/index.wxml` 模板和 `pages/index/index.wxcss` 样式文件及 `pages/index/index.js` 脚本、`pages/index/index.json` 配置

页面构造器 `Page()` 用来注册一个小程序页面，里面包含生命周期函数和页面用户行为

```js
Page({
  data: { text: "This is page data." }, // 页面的初始数据
  onLoad: function(options) {
	  this.foo()
	  this.setData({ text: 'new data' }, function() { // 只需要写修改的字段，其他字段会自动很并
		  // 本次更新之后触发
    }) // 使用 setData 更新数据
  }, // 生命周期函数--监听页面加载，触发时机早于onShow和onReady
  onReady: function() { }, // 监听页面初次渲染完成
  onShow: function() { }, // 监听页面显示，触发事件早于onReady
  onHide: function() { }, // 监听页面隐藏，wx.navigateTo切换到其他页面、底部tab切换时触发
  onUnload: function() { }, // 监听页面卸载，wx.redirectTo或wx.navigateBack返回到其他页时，当前页面会被微信客户端销毁回收
  onPullDownRefresh: function() { }, // 页面相关事件处理函数--监听用户下拉动作，需要在app.json的window选项中或页面配置page.json中设置enablePullDownRefresh为true。当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新。
  onReachBottom: function() { }, // 页面上拉触底事件的处理函数，在app.json的window选项中或页面配置page.json中设置触发距离onReachBottomDistance。在触发距离内滑动期间，本事件只会被触发一次。
  onShareAppMessage: function () {
	  return {
			title: '自定义转发标题',
			path: '/page/user?id=123'
    }
  }, // 用户点击右上角转发
  onPageScroll: function({ scrollTop }) { }, // 页面滚动触发事件的处理函数
  tapName: function(event) {
    console.log(event)
  },
	foo: function() {},  // 可以添加任意的函数或数据，在Page实例的其他函数中用 this 可以访问
	fun() {}
})
```

![页面生命周期](https://cdn.wallleap.cn/img/pic/illustration/20250307104306214.png?imageSlim)

例如

```js
Page({
  data: {
    latitude: 0,
    longitude: 0,
  },

  onLoad() {
    wx.getLocation({
      type: 'wgs84',
      success: (res) => {
        console.log(res.longitude, res.latitude)
        this.setData({
          latitude: res.latitude,  // 纬度
          longitude: res.longitude  // 经度
        })
      }
    })
  },
})
```

页面跳转 路由

`wx.navigateTo` 或 `Router.navigateTo`（之后的也有 Router 和组件）、组件 [`<navigator open-type="navigateTo"/>`](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html)，`navigateTo` 的目标必须为非 tabBar 页面

`[ pageA, pageB, pageC ]` 限制了这个页面栈的最大层级为 10 层 ，使用 `wx.navigateTo({ url: 'pageD' })` 可以往当前页面栈多推入一个 pageD，此时页面栈变成 `[ pageA, pageB, pageC, pageD ]`。

使用 `wx.navigateBack()` 可以退出当前页面栈的最顶上页面，此时页面栈变成 `[ pageA, pageB, pageC ]`。

使用 `wx.redirectTo({ url: 'pageE' })` 是替换当前页变成 pageE，此时页面栈变成 `[ pageA, pageB, pageE ]`，当页面栈到达 10 层没法再新增的时候，往往就是使用 redirectTo 这个 API 进行页面跳转。

使用 `wx.switchTab({ url: 'pageF' })`，此时原来的页面栈会被清空（除了已经声明为 Tabbar 页 pageA 外其他页面会被销毁），然后会切到 pageF 所在的 tab 页面，页面栈变成 `[ pageF ]`，此时点击 Tab1 切回到 pageA 时，pageA 不会再触发 onLoad，因为 pageA 没有被销毁。

补充一下，`wx.navigateTo` 和 `wx.redirectTo` 只能打开非 TabBar 页面，`wx.switchTab` 只能打开 Tabbar 页面。

我们还可以使用 `wx. reLaunch({ url: 'pageH' })` 重启小程序，并且打开 pageH，此时页面栈为 `[ pageH ]`

关闭小窗页面 `openType="dismissPip"`

| 路由方式     | 触发时机                   | 路由前页面生命周期 | 路由后页面生命周期      |
| -------- | ---------------------- | --------- | -------------- |
| 初始化      | 小程序打开的第一个页面            |           | onLoad, onShow |
| 打开新页面 调用 | API wx.navigateTo      | onHide    | onLoad, onShow |
| 页面重定向 调用 | API wx.redirectTo      | onUnload  | onLoad, onShow |
| 页面返回 调用  | API wx.navigateBack    | onUnload  | onShow         |
| Tab      | 切换 调用 API wx.switchTab | 请参考表 3-6  | 请参考表 3-6       |
| 重启动      | 调用 API wx.reLaunch     | onUnload  | onLoad, onShow |

[路由页面监听](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route-event-listener.html)

页面传递参数

```js
// pages/list/list.js
// 列表页使用navigateTo跳转到详情页
wx.navigateTo({ url: 'pages/detail/detail?id=1&other=abc' })

// pages/detail/detail.js
Page({
  onLoad: function(option) {
        console.log(option.id)
        console.log(option.other)
  }
})
```

在组件中绑定一个时间处理函数

```js
<view id="tapTest" data-hi="Weixin" bindtap="tapName"> Click me! </view>
```

捕获阶段 `capture-bind:touchstart`、`capture-catch:touchstart`（catch 中再有 capture-bind 只会触发 catch）

事件处理函数

```js
Page({
  tapName: function(event) {
    console.log(event)
  }
})
```

其他事件

| 类型                 | 触发条件                                               |
| ------------------ | -------------------------------------------------- |
| touchstart         | 手指触摸动作开始                                           |
| touchmove          | 手指触摸后移动                                            |
| touchcancel        | 手指触摸动作被打断，如来电提醒，弹窗                                 |
| touchend           | 手指触摸动作结束                                           |
| tap                | 手指触摸后马上离开                                          |
| longpress          | 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 |
| longtap            | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）            |
| transitionend      | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发    |
| animationstart     | 会在一个 WXSS animation 动画开始时触发                        |
| animationiteration | 会在一个 WXSS animation 一次迭代结束时触发                      |
| animationend       | 会在一个 WXSS animation 动画完成时触发                        |

wxml

```wxml
<map latitude="{{ latitude }}" longitude="{{ longitude }}"></map>
```

页面共用相同的数据和方法，可以抽离成 behavior

```js
// my-behavior.js
module.exports = Behavior({
  data: {
    sharedText: 'This is a piece of data shared between pages.'
  },
  methods: {
    sharedMethod: function() {
      this.data.sharedText === 'This is a piece of data shared between pages.'
    }
  }
})
```

之后使用

```js
// page-a.js
var myBehavior = require('./my-behavior.js')
Page({
  behaviors: [myBehavior],
  onLoad: function() {
    this.data.sharedText === 'This is a piece of data shared between pages.'
  }
})
```

具体用法参见 [behaviors](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html) 。

复杂页面使用 Component，可以使用 [自定义组件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/)

```js
Component({
  data: {
    text: "This is page data."
  },
  methods: { // 方法需要放到这里面
    onLoad: function(options) {
      // 页面创建时执行
    },
    onPullDownRefresh: function() {
      // 下拉刷新时执行
    },
    // 事件响应函数
    viewTap: function() {
      // ...
    }
  }
})
```

## 程序

在 `app.js` 中能直接使用 `App()` 构造器来注册一个程序 APP，在其他 JS 文件中则可以通过 `var appInstance = getApp()` 获得 App 实例

构造器中接收一个对象，里面接收的是声明周期函数

```js
App({
  onLaunch: function(options) {},
  onShow: function(options) {},
  onHide: function() {},
  onError: function(msg) {},
  globalData: 'I am global data'
})
```

| 参数属性     | 类型       | 描述                                           |
| -------- | -------- | -------------------------------------------- |
| onLaunch | Function | 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）             |
| onShow   | Function | 当小程序启动，或从后台进入前台显示，会触发 onShow                 |
| onHide   | Function | 当小程序从前台进入后台，会触发 onHide                       |
| onError  | Function | 当小程序发生脚本错误，或者 API 调用失败时，会触发 onError 并带上错误信息  |
| 其他字段     | 任意       | 可以添加任意的函数或数据到 Object 参数中，在 App 实例回调用 this 可以访问 |

onLaunch 和 onShow 函数中可以带参数

| 字段                     | 类型     | 描述                             |
| ---------------------- | ------ | ------------------------------ |
| path                   | String | 打开小程序的页面路径                     |
| query                  | Object | 打开小程序的页面参数 query                |
| scene                  | Number | 打开小程序的场景值，详细场景值请参考小程序官方文档      |
| shareTicket            | String | shareTicket，详见小程序官方文档          |
| referrerInfo           | Object | 当场景为由从另一个小程序或公众号或 App 打开时，返回此字段  |
| referrerInfo.appId     | String | 来源小程序或公众号或 App 的 appId，详见下方说明    |
| referrerInfo.extraData | Object | 来源小程序传过来的数据，scene=1037 或 1038 时支持 |

小程序全局数据

```js
// app.js
App({
  globalData: 'I am global data' // 全局共享数据
})

// 其他页面脚本other.js
var appInstance = getApp()
console.log(appInstance.globalData) // 输出: I am global data
```

所有页面的脚本逻辑都跑在同一个 JsCore 线程，页面使用 setTimeout 或者 setInterval 的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理。

## 组件

一个小程序页面可以分解成多个部分组成，组件就是小程序页面的基本组成单元

组件文档：<https://developers.weixin.qq.com/miniprogram/dev/component/>

## API

小程序提供的 API 按照功能主要分为几大类：网络、媒体、文件、数据缓存、位置、设备、界面、界面节点信息还有一些特殊的开放接口，我们介绍一下 API 一般调用的约定：

1. `wx.on*` 开头的 API 是监听某个事件发生的 API 接口，接受一个 Callback 函数作为参数。当该事件触发时，会调用 Callback 函数。
2. 如未特殊约定，多数 API 接口为异步接口 ，都接受一个 Object 作为参数。
3. API 的 Object 参数一般由 success、fail、complete 三个回调来接收接口调用结果，示例代码如代码清单 3-17 所示，详细说明如表 3-9 所示。
4. `wx.get*` 开头的 API 是获取宿主环境数据的接口。
5. `wx.set*` 开头的 API 是写入数据到宿主环境的接口。

例如发起请求

```js
wx.request({
	url: 'test.php',
	data: {},
	header: { 'content-type': 'application/json' },
	success: function(res) {
		 // 收到https服务成功后返回
		 console.log(res.data)
	},
	fail: function() {
		 // 发生网络错误等情况触发
	},
	complete: function() {
		 // 成功或者失败后触发
	}
})
```

API 调用大多都是异步的，其次，有部分 API 会拉起微信的原生界面，此时会触发 Page 的 onHide 方法，当用户从原生界面返回到小程序时，会触发 Page 的 onShow 方法。

重要的接口

通过 `wx.getSystemInfoSync()` 获取设备信息，进行特殊处理

兼容处理

```js
if (wx.openBluetoothAdapter) {
  wx.openBluetoothAdapter()
} else {
  // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示
  wx.showModal({
    title: '提示',
    content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'
  })
}

// 判断接口及其参数在宿主环境是否可用
wx.canIUse('openBluetoothAdapter')
wx.canIUse('getSystemInfoSync.return.screenWidth')
wx.canIUse('getSystemInfo.success.screenWidth')
wx.canIUse('showToast.object.image')
wx.canIUse('onCompassChange.callback.direction')
wx.canIUse('request.object.method.GET')

 // 判断组件及其属性在宿主环境是否可用
wx.canIUse('contact-button')
wx.canIUse('text.selectable')
wx.canIUse('button.open-type.contact')
```

读写本地数据缓存 通过 `wx.getStorage`/`wx.getStorageSync` 读取本地缓存，通过 `wx.setStorage`/`wx.setStorageSync` 写数据到缓存

```js
wx.getStorage({
  key: 'key1',
  success: function(res) {
    // 异步接口在success回调才能拿到返回值
    var value1 = res.data
  },
  fail: function() {
    console.log('读取key1发生错误')
  }
})

try{
  // 同步接口立即返回值
  var value2 = wx.getStorageSync('key2')
}catch (e) {
  console.log('读取key2发生错误')
}

// 异步接口在success/fail回调才知道写入成功与否
wx.setStorage({
  key:"key",
  data:"value1"
  success: function() {
    console.log('写入value1成功')
  },
  fail: function() {
    console.log('写入value1发生错误')
  }
})

try{
  // 同步接口立即写入
  wx.setStorageSync('key', 'value2')
  console.log('写入value2成功')
}catch (e) {
  console.log('写入value2发生错误')
}
```

每个小程序的缓存空间上限为 10MB

利用 `wx.scanCode` 获取二维码的数据

```js
//page.js
Page({
  // 点击“扫码订餐”的按钮，触发tapScan回调
  tapScan: function() {
    // 调用wx.login获取微信登录凭证
    wx.scanCode({
      success: function(res) {
        var num = res.result // 获取到的num就是餐桌的编号
      }
    })
  }
})
```

利用 `wx.getNetworkType` 获取网络状态

```js
//page.js
Page({
  // 点击“预览文档”的按钮，触发tap回调
  tap: function() {
    wx.getNetworkType({
      success: function(res) {
        // networkType字段的有效值：
        // wifi/2g/3g/4g/unknown(Android下不常见的网络类型)/none(无网络)
        if (res.networkType == 'wifi') {
          // 从网络上下载pdf文档
          wx.downloadFile({
            url:'http://test.com/somefile.pdf',
            success: function (res) {
              // 下载成功之后进行预览文档
              wx.openDocument({
                filePath: res.tempFilePath
              })
            }
          })
        } else {
          wx.showToast({ title: '当前为非Wifi环境' })
        }
      }
    })
  }
})
```

可以动态监听网络状态变化的接口 `wx.onNetworkStatusChange`

云开发 API，可以直接在小程序端调用服务端的 [云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloud/guide/functions.html)

```js
wx.cloud.callFunction({
  // 云函数名称
  name: 'cloudFunc',
  // 传给云函数的参数
  data: {
    a: 1,
    b: 2,
  },
  success: function(res) {
    console.log(res.result) // 示例
  },
  fail: console.error
})

// 此外，云函数同样支持promise形式调用
```

API 接口文档：<https://developers.weixin.qq.com/miniprogram/dev/api/>

## 交互反馈

触摸样式

```
/*page.wxss */

.hover{

  background-color: gray;

}

<!--page.wxml -->

<button hover-class="hover"> 点击button </button>

<view hover-class="hover"> 点击view</view>
```

button 的 loading

```
<!--page.wxml -->
<button loading="{{loading}}" bindtap="tap">操作</button>

//page.js
Page({
  data: { loading: false },
  tap: function() {
    // 把按钮的loading状态显示出来
    this.setData({
      loading: true
    })
    // 接着做耗时的操作
  }
})
```

显示和隐藏 Toast

```js
wx.showToast({ // 显示Toast
	title: '已发送',
	icon: 'success',
	duration: 1500
})

// wx.hideToast() // 隐藏Toast
```

显示模态对话框

```js
wx.showModal({
	title: '标题',
	content: '告知当前状态，信息和解决方法',
	confirmText: '主操作',
	cancelText: '次要操作',
	success: function(res) {
		if (res.confirm) {
			console.log('用户点击主操作')
		} else if (res.cancel) {
			console.log('用户点击次要操作')
		}
	}
})
```

下拉刷新

```js
//page.json
{"enablePullDownRefresh": true }

//page.js
Page({
  onPullDownRefresh: function() {
    // 用户触发了下拉刷新操作
    // 拉取新数据重新渲染界面
    // wx.stopPullDownRefresh() // 可以停止当前页面的下拉刷新。
  }
})
```

上拉触底

```js
//page.json
// 界面的下方距离页面底部距离小于onReachBottomDistance像素时触发onReachBottom回调
{"onReachBottomDistance": 100 }

//page.js
Page({
  onReachBottom: function() {
    // 当界面的下方距离页面底部距离小于100像素时触发回调
  }
})
```

部分滚动使用 `scroll-view` 容器组件

## 发请求

```js
wx.request({
  url: 'https://test.com/getinfo',
  success: function(res) {
    console.log(res)// 服务器回包信息
  }
})
```

| **参数名**  | **类型**        | **必填** | **默认值** | **描述**                                                                           |
| -------- | ------------- | ------ | ------- | -------------------------------------------------------------------------------- |
| url      | String        | 是      |         | 开发者服务器接口地址                                                                       |
| data     | Object/String | 否      |         | 请求的参数                                                                            |
| header   | Object        | 否      |         | 设置请求的 header，header 中不能设置 Referer，默认 header['content-type'] = 'application/json' |
| method   | String        | 否      | GET     | （需大写）有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT                   |
| dataType | String        | 否      | json    | 回包的内容格式，如果设为 json，会尝试对返回的数据做一次 JSON 解析                                           |
| success  | Function      | 否      |         | 收到开发者服务成功返回的回调函数，其参数是一个 Object，见表 4-2。                                           |
| fail     | Function      | 否      |         | 接口调用失败的回调函数                                                                      |
| complete | Function      | 否      |         | 接口调用结束的回调函数（调用成功、失败都会执行）                                                         |

网络请求必须是 https 协议请求，因此开发者服务器必须提供 HTTPS 服务的接口，同时为了保证小程序不乱用任意域名的服务，wx.request 请求的域名需要在小程序管理平台进行配置

`app.json` 中指定请求超时时间

```json
{
  "networkTimeout": {
    "request": 3000
  }
}
```

各类网络请求的超时时间，单位均为毫秒，默认为 60000

- `wx.request`
- `wx.connectSocket`
- `wx.uploadFile`
- `ex.downloadFile`

示例

```js
var hasClick = false;

Page({
  tap: function() {
    if (hasClick) {
      return
    }
    hasClick = true
    wx.showLoading()

    wx.request({
      url: 'https://test.com/getinfo',
      method: 'POST',
      header: { 'content-type':'application/json' },
      data: { },
      success: function (res) {
        if (res.statusCode === 200) {
          console.log(res.data)// 服务器回包内容
        }
      },
      fail: function (res) {
        wx.showToast({ title: '系统错误' })
      },
      complete: function (res) {
        wx.hideLoading()
        hasClick = false
      }
    })
  }
})
```

缓存请求到的数据，当进小程序的时候可以不是白屏

```js
Page({
  onLoad: function() {
    var that = this
    var list =wx.getStorageSync("list")
    if (list) { // 本地如果有缓存列表，提前渲染
      that.setData({
        list: list
      })
    }
    wx.request({
      url: 'https://test.com/getproductlist',
      success: function (res) {
        if (res.statusCode === 200) {
          list = res.data.list
          that.setData({ // 再次渲染列表
            list: list
          })
          wx.setStorageSync("list",list) // 覆盖缓存数据
        }
      }
    })
  }
})
```

## 微信登录

步骤：

1. `wx.login()` 获取到微信登录凭证 code，即微信后台生成一张临时的身份证，其有效时间仅为 5 分钟，
2. `wx.request()` 把 code 带到自己服务器
3. 小程序通过 code 和其他信息换取用户 id
4. 服务器中绑定微信用户 id 和自己业务用户 id
5. 服务器生成自己业务登录凭证 SessionID
6. 返回业务登录凭证 SessionID 给小程序
7. 小程序下次 `wx.request()` 携带 SessionID

```js
Page({
  tapLogin: function() {
    wx.login({
      success: function(res) {
        if (res.code) {
          wx.request({
            url: 'https://test.com/login',
            data: {
              username: 'zhangsan', // 用户输入的账号
              password: 'pwd123456', // 用户输入的密码
              code: res.code
            },
            success: function(res) {
              // 登录成功
              if (res.statusCode === 200) {
	              var data = res.data
	              console.log(data.sessionId)// 服务器回包内容
	              // 把 SessionId 和过期时间放在内存中的全局对象和本地缓存里边
	              app.globalData.sessionId = data.sessionId
								wx.setStorageSync('SESSIONID',data.sessionId)
								// 假设登录态保持1天
								var expiredTime = +new Date() +1*24*60*60*1000
								app.globalData.expiredTime = expiredTime
								wx.setStorageSync('EXPIREDTIME',expiredTime)
              }
            }
          })
        } else {
          console.log('获取用户登录态失败！' + res.errMsg)
        }
      }
    });
  }
})
```

服务器端接收到信息之后，需要请求微信服务器 `https://api.weixin.qq.com/sns/jscode2session?appid=<AppId>&secret=<AppSecret>&js_code=<code>&grant_type=authorization_code`

- AppId 和 AppSecret 需要到小程序管理平台的开发设置中找
- code 即传过来的 code

返回字段

| **字段**      | **描述**                             |
| ----------- | ---------------------------------- |
| openid      | 微信用户的唯一标识                          |
| session_key | 会话密钥                               |
| unionid     | 用户在微信开放平台的唯一标识符。本字段在满足一定条件的情况下才返回。 |

- openid 就是前文一直提到的微信用户 id，可以用这个 id 来区分不同的微信用户
- session_key 则是微信服务器给开发者服务器颁发的身份凭证，开发者可以用 session_key 请求微信服务器其他接口来获取一些其他信息，这个不需要给前端

现在获取到了 openid 就可以和业务用户 id 进行绑定了，绑定之后再次登录的时候就可以不需要帐号密码，通过 `wx.login()` 获得 code 之后就可以直接得到 openid 之后查到业务侧的用户身份 id

登录成功之后服务端应该生成一个 SessionId，并返回给小程序，然后存储起来，每次请求携带上这个 SessionId，之后过期就重新登录

```js
//app.js
App({
  onLaunch: function(options) {
    var sessionId =wx.getStorageSync('SESSIONID')
    var expiredTime =wx.getStorageSync('EXPIREDTIME')
    var now = +new Date()

    if (now - expiredTime <=1*24*60*60*1000) {
      this.globalData.sessionId = sessionId
      this.globalData.expiredTime = expiredTime
    }
  },
  globalData: {
    sessionId: null,
    expiredTime: 0
  }
})
```

## 手动触发更新

```js
const updateManager = wx.getUpdateManager()

updateManager.onCheckForUpdate(function (res) {
  // 请求完新版本信息的回调
  console.log(res.hasUpdate)
})

updateManager.onUpdateReady(function () {
  wx.showModal({
    title: '更新提示',
    content: '新版本已经准备好，是否重启应用？',
    success(res) {
      if (res.confirm) {
        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
        updateManager.applyUpdate()
      }
    }
  })
})

updateManager.onUpdateFailed(function () {
  // 新版本下载失败
})
```

## 服务器端调用

<https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/>

## 云开发

可以省去服务器费用

<https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloud/basis/getting-started.html>

一个环境对应一整套独立的云开发资源，包括数据库、存储空间、云函数等资源。各个环境是相互独立的，用户开通云开发后即创建了一个环境。在实际开发中，**建议每一个正式环境都搭配一个测试环境**，所有功能先在测试环境测试完毕后再上到正式环境，例如一个创建为 `test` 测试环境，一个创建为 `release` 正式环境。

在 `wx.cloud.init` 后会在调试器中输出 SDK 中所使用的默认环境

登录云服务：进入 [腾讯云控制台](https://cloud.tencent.com/login)，在登录方式处选择“小程序公众号”方式，扫码后选择所开通微信云开发的小程序，即可登录该小程序所对应的腾讯云账号。

### JSON 数据库

每条记录都是一个 JSON 格式的对象

数据库（database） → 集合（collection） → 记录（record/doc） → 字段（field）

示例：

```json
[
  {
    "_id": "Wzh76lk5_O_dt0vO",
    "title": "The Catcher in the Rye",
    "author": "J. D. Salinger",
    "characters": [
      "Holden Caulfield",
      "Stradlater",
      "Mr. Antolini"
    ],
    "publishInfo": {
      "year": 1951,
      "country": "United States"
    }
  },
  {
    "_id": "Wzia0lk5_O_dt0vR",
    "_openid": "ohl4L0Rnhq7vmmbT_DaNQa4ePaz0",
    "title": "The Lady of the Camellias",
    "author": "Alexandre Dumas fils",
    "characters": [
      "Marguerite Gautier",
      "Armand Duval",
      "Prudence",
      "Count de Varville"
    ],
    "publishInfo": {
      "year": 1848,
      "country": "France"
    }
  }
]
```

**初始化**

```js
const cloud = require('wx-server-sdk');

// wx.cloud.init()
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,  // string | object
  traceUser: true  // 是否在将用户访问记录到用户管理中，在控制台中可见
});
```

数据库连接

```js
const db = wx.cloud.database({
  env: 'test'
})  // 不写参数就使用默认环境
```

创建集合

```js
db.createCollection('todos')
```

获取集合的引用

```js
const todos = db.collection('todos')
```

通过此引用在该集合上进行增删查改的操作，除此之外，还可以通过集合上的 `doc` 方法来获取集合中一个指定 ID 的记录的引用

```js
const todo = db.collection('todos').doc('todo-identifiant-aleatoire')
```

**支持的数据类型**

- String：字符串
- Number：数字
- Object：对象
- Array：数组
- Bool：布尔值
- Date：时间
- Geo：多种地理位置类型，[详见下](https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloud/guide/database/data-type.html#%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE)
- Null

权限

以下按照权限级别从宽到紧排列如下：

- 仅创建者可写，所有人可读：数据只有创建者可写、所有人可读；比如文章。
- 仅创建者可读写：数据只有创建者可读写，其他用户不可读写；比如用私密相册。
- 仅管理端可写，所有人可读：该数据只有管理端可写，所有人可读；如商品信息。
- 仅管理端可读写：该数据只有管理端可读写；如后台用的不暴露的数据。

通过 `add` 插入

```js
db.collection('todos').add({
  // data 字段表示需新增的 JSON 数据
  data: {
    // _id: 'todo-identifiant-aleatoire', // 可选自定义 _id，在此处场景下用数据库自动分配的就可以了
    description: "learn cloud database",
    due: new Date("2018-09-01"),
    tags: [
      "cloud",
      "database"
    ],
    // 为待办事项添加一个地理位置（113°E，23°N）
    location: new db.Geo.Point(113, 23),
    done: false
  },
  success: function(res) {
    // res 是一个对象，其中有 _id 字段标记刚创建的记录的 id
    console.log(res)
  },
	fail: function() {},
	complete: function() {},
})

// Promise 风格
db.collection('todos').add({
  // data 字段表示需新增的 JSON 数据
  data: {
    description: "learn cloud database",
    due: new Date("2018-09-01"),
    tags: [
      "cloud",
      "database"
    ],
    location: new db.Geo.Point(113, 23),
    done: false
  }
})
.then(res => {
  console.log(res)
})
```

示例

```js
const cloud = require('wx-server-sdk')
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})
const db = cloud.database()
exports.main = async (event, context) => {
  try {
    return await db.collection('todos').add({
      // data 字段表示需新增的 JSON 数据
      data: {
        description: "learn cloud database",
        due: new Date("2018-09-01"),
        tags: [
          "cloud",
          "database"
        ],
        // 位置（113°E，23°N）
        location: new db.Geo.Point(113, 23),
        done: false
      }
    })
  } catch(e) {
    console.error(e)
  }
}
```

通过 `doc` `get` 获取一个记录的数据

```js
db.collection('todos').doc('todo-identifiant-aleatoire').get({
  success: function(res) {
    // res.data 包含该记录的数据
    console.log(res.data)
  }
})

// Promise 风格
db.collection('todos').doc('todo-identifiant-aleatoire').get().then(res => {
  // res.data 包含该记录的数据
  console.log(res.data)
})
```

通过 `where` `get` 找满足条件的多个记录的数据

```js
// 1. 获取数据库引用
const db = cloud.database()
// 2. 构造查询语句
// collection 方法获取一个集合的引用
// where 方法传入一个对象，数据库返回集合中字段等于指定值的 JSON 文档。API 也支持高级的查询条件（比如大于、小于、in 等），具体见文档查看支持列表
// get 方法会触发网络请求，往数据库取数据
exports.main = async (event) => {
	const result = db.collection('books').where({
	  publishInfo: {
	    country: 'United States'
	  }
	}).get({
	  success: function(res) {
	  // 输出 [{ "title": "The Catcher in the Rye", ... }]
	  console.log(res)
	 }
	})
	return {
		result
	}
}
```

获取整个集合的数据

```js
db.collection('todos').get({
  success: function(res) {
    // res.data 是一个包含集合中有权限访问的所有记录的数据，不超过 20 条
    console.log(res.data)
  }
})

// Promise 风格
db.collection('todos').get().then(res => {
  // res.data 是一个包含集合中有权限访问的所有记录的数据，不超过 20 条
  console.log(res.data)
})
```

分批次获取

```js
const cloud = require('wx-server-sdk')
cloud.init()
const db = cloud.database()
const MAX_LIMIT = 100
exports.main = async (event, context) => {
  // 先取出集合记录总数
  const countResult = await db.collection('todos').count()
  const total = countResult.total
  // 计算需分几次取
  const batchTimes = Math.ceil(total / 100)
  // 承载所有读操作的 promise 的数组
  const tasks = []
  for (let i = 0; i < batchTimes; i++) {
    const promise = db.collection('todos').skip(i * MAX_LIMIT).limit(MAX_LIMIT).get()
    tasks.push(promise)
  }
  // 等待所有
  return (await Promise.all(tasks)).reduce((acc, cur) => {
    return {
      data: acc.data.concat(cur.data),
      errMsg: acc.errMsg,
    }
  })
}
```

查询指令 `db.command` <https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloud/guide/database/query.html>

使用 `update` 和 `set` 更新替换

```js
db.collection('todos').doc('todo-identifiant-aleatoire').update({
  // data 传入需要局部更新的数据
  data: {
    // 表示将 done 字段置为 true
    done: true
  },
  success: function(res) {
    console.log(res.data)
  }
})
```

更新指令 `db.command` <https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloud/guide/database/update.html>

`remove` 删除一条记录

```js
db.collection('todos').doc('todo-identifiant-aleatoire').remove({
  success: function(res) {
    console.log(res.data)
  }
})
```

删除满足条件的记录

```js
// 使用了 async await 语法
const cloud = require('wx-server-sdk')
const db = cloud.database()
const _ = db.command

exports.main = async (event, context) => {
  try {
    return await db.collection('todos').where({
      done: true
    }).remove()
  } catch(e) {
    console.error(e)
  }
}
```

实时监听数据修改进行推送

```js
const db = wx.cloud.database()
const watcher = db.collection('todos')
  // 按 progress 降序
  .orderBy('progress', 'desc')
  // 取按 orderBy 排序之后的前 10 个
  .limit(10)
  .where({
    team: 'our dev team'
  })
  .watch({
    onChange: function(snapshot) {
      console.log('docs\'s changed events', snapshot.docChanges)
      console.log('query result snapshot after the event', snapshot.docs)
      console.log('is init data', snapshot.type === 'init')
    },
    onError: function(err) {
      console.error('the watch closed because of error', err)
    }
  })
// ...
// 等到需要关闭监听的时候调用 close() 方法
// watcher.close()
```

开始使用，例如 `cloudFunctions` **云函数**

新建 `createCollection/index.js` 创建集合云函数

```js
const cloud = require('wx-server-sdk');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();

// 创建集合云函数入口函数
exports.main = async (event, context) => {
  try {
    // 创建集合
    await db.createCollection(event.collection || 'sales');
    return {
      success: true,
      data: 'create collection success'
    };
  } catch (e) {
    // 这里catch到的是该collection已经存在，从业务逻辑上来说是运行成功的，所以catch返回success给前端，避免工具在前端抛出异常
    return {
      success: true,
      data: 'collection already exists'
    };
  }
};
```

添加一条数据 `addOneRecord/index.js`

```js
const cloud = require('wx-server-sdk');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();

exports.main = async (event, context) => {
	await db.collection(event.collection || 'sales').add({
		// data 字段表示需新增的 JSON 数据
		data: event.data
	});
	return {
		success: true
	};
};
```

获取数据 `fetchData/index.js`

```js
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

const db = cloud.database();

exports.main = async (event, context) => {
  const result = await db.collection(event.collection || 'sales')
    .skip(0)
    .limit(10)
    .get();
  return {
    dataList: result?.data,
  };
};
```

获取 OPENID `getOpendId/index.js`

```js
const cloud = require('wx-server-sdk');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

// 获取openId云函数入口函数
exports.main = async (event, context) => {
  // 获取基础信息
  const wxContext = cloud.getWXContext();

  return {
    openid: wxContext.OPENID,
    appid: wxContext.APPID,
    unionid: wxContext.UNIONID,
  };
};
```

入口函数 `index.js`

```js
const getOpenId = require('./getOpenId/index');
const createCollection = require('./createCollection/index');
const addOneRecord = require('./addOneRecord/index');
const fetchData = require('./fetchData/index');

// 云函数入口函数
exports.main = async (event, context) => {
  switch (event.type) {
    case 'getOpenId':
      return await getOpenId.main(event, context);
    case 'createCollection':
      return await createCollection.main(event, context);
    case 'addOneRecord':
      return await addOneRecord.main(event, context);
    case 'fetchData':
      return await fetchData.main(event, context)
  }
};
```

在小程序中调用

```js
Page({
  data: {
    avatarUrl: defaultAvatarUrl,
    openId: '',
    todoList: [{
	    _id: 'todo-identifiant-aleatoire',
			description: "learn cloud database",
			due: new Date("2018-09-01"),
			tags: [
				"cloud",
				"database"
			],
			location: '',
			done: false,
    },]
  },
	onLoad() {
		this.fetchTodoList()
	},
	onCreateCollection() {
		wx.cloud.callFunction({
			name: 'cloudFunctions',
			data: {
				type: 'createCollection',
				collection: 'todos'
			}
		}).then(res => {
			console.log(res)
		})
	},
	onGetOpenId() {
		wx.cloud.callFunction({
			name: 'cloudFunctions',
			data: {
				type: 'getOpenId',
			},
			complete: res => {
				this.setData({
					openId: res?.result?.openid
				})
				console.log(this.data.openId)
      }
		})
	},
	onAddOneRecord() {
		wx.cloud.callFunction({
			name: 'cloudFunctions',
			data: {
				type: 'addOneRecord',
				data: {
			    // _id: 'todo-identifiant-aleatoire', // 可选自定义 _id，在此处场景下用数据库自动分配的就可以了
			    description: "learn cloud database",
			    due: new Date("2018-09-01"),
			    tags: [
			      "cloud",
			      "database"
			    ],
			    // 为待办事项添加一个地理位置（113°E，23°N）
			    location: {
            type: 'Point',
            coordinates: [113, 23]
          },,
			    done: false,
			    openId: this.data.openId
				}
			},
		})
	},
	async fetchTodoList() {
		try {
      const res = await wx.cloud.callFunction({
        name: "cloudFunctions",
        data: {
	        type: "fetchData",
					collection: 'todos'
				},
      });
      const todoList = res?.result?.dataList || [];
      this.setData({
				todoList
      });
      console.log(this.data.todoList)
    } catch (e) {
      const { errCode, errMsg } = e;
      if (errMsg.includes("Environment not found")) {
        this.setData({
          showTip: true,
          title: "云开发环境未找到",
          content:
            "如果已经开通云开发，请检查环境ID与 `miniprogram/app.js` 中的 `env` 参数是否一致。",
        });
        return;
      }
      if (errMsg.includes("FunctionName parameter could not be found")) {
        this.setData({
          showTip: true,
          title: "请上传云函数",
          content:
            "按照教程指引更新云函数，保存完成后，在'cloudfunctions/quickstartFunctions'目录右键，选择【上传并部署-云端安装依赖】，等待云函数上传完成后重试。",
        });
        return;
      }
    }
	}
})
```

### 数据模型

![](https://cdn.wallleap.cn/img/pic/illustration/20250309130445584.png?imageSlim)

核心特点：

- **数据校验**：自动检查数据正确性。
- **关联关系处理**：简化数据间的关系管理。
- **自动生成代码**：快速生成 CRUD 操作代码。
- **CMS 管理端**：提供易用的数据管理界面。
- **AI 智能分析**：利用 AI 分析数据，发现有价值信息。
- **MySQL 等高级查询支持**：支持复杂查询操作。

数据模型的 SDK 包含字段检查、增删改查、关联查询、返回字段控制等能力，使用 SDK 调用数据模型只要 2 步：初始化 SDK、调用内置的 SDK 方法。

```js
const { init } = require('@cloudbase/wx-cloud-client-sdk')

const client = init(wx.cloud)
const models = client.models

try {
  await models.post.create({
    data: {
      title: "错误示例",
      body: 123456, // 错误：数字而非字符串类型
    },
  });
} catch (error) {
  console.error("数据校验失败：", error);
}
```

使用 `list()` 拉取

```js
const { data } = await models.post.list({
  // 只查询必要的字段
  select: {
    _id: true,
    title: true,
    updatedAt: true, 
    // 查询关联的评论模型的数据
    comments: {
      _id: true,
      createdAt: true,
      comment: true,
    }, // 只返回下面所需的评论模型的字段
  },
  filter: {
    // 可以根据条件过滤
    where: {
      // title: {
      //   $eq: 'Hello World'
      // }
    },
  },
  getCount: true, // 开启用来获取总数
});
```

### 存储

在小程序端可以分别调用 `wx.cloud.uploadFile` 和 `wx.cloud.downloadFile` 完成上传和下载云文件操作

```js
let fileId
// 让用户选择一张图片
wx.chooseImage({
  success: chooseResult => {
    // 将图片上传至云存储空间
    wx.cloud.uploadFile({
      // 指定上传到的云路径
      cloudPath: 'my-photo.png',
      // 指定要上传的文件的小程序临时文件路径
      filePath: chooseResult.tempFilePaths[0],
      // 成功回调
      success: res => {
        console.log('上传成功', res)
        fileId = res.fileId
      },
    })
  },
})

// 下载
wx.cloud.downloadFile({
  fileID: '', // 文件 ID
  success: res => {
    // 返回临时文件路径
    console.log(res.tempFilePath)
  },
  fail: console.error
})

// 删除
wx.cloud.deleteFile({
  fileList: ['a7xzcb'],
  success: res => {
    // handle success
    console.log(res.fileList)
  },
  fail: console.error
})

// 换取临时链接 2小时
wx.cloud.getTempFileURL({
  fileList: ['cloud://xxx.png'],
  success: res => {
    // fileList 是一个有如下结构的对象数组
    // [{
    //    fileID: 'cloud://xxx.png', // 文件 ID
    //    tempFileURL: '', // 临时文件网络链接
    //    maxAge: 120 * 60 * 1000, // 有效期
    // }]
    console.log(res.fileList)
  },
  fail: console.error
})
```

支持在 `image`、`audio` 等组件中传入云文件 ID

文件名命名限制：

- 不能为空
- 不能以/开头
- 不能出现连续/
- 编码长度最大为 850 个字节
- 推荐使用大小写英文字母、数字，即 [a-z，A-Z，0-9] 和符号 -，!，_，.，* 及其组合
- 不支持 ASCII 控制字符中的字符上 (↑)，字符下 (↓)，字符右 (→)，字符左 (←)，分别对应 CAN(24)，EM(25)，SUB(26)，ESC(27)
- 如果用户上传的文件或文件夹的名字带有中文，在访问和请求这个文件或文件夹时，中文部分将按照 URL Encode 规则转化为百分号编码。
- 不建议使用的特殊字符: ` ^ " \ { } [ ] ~ % # \ > < 及 ASCII 128-255 十进制
- 可能需特殊处理后再使用的特殊字符: ， : ; = & $ @ + ?（空格）及 ASCII 字符范围：00-1F 十六进制（0-31 十进制）以及 7F（127 十进制）

### 云函数

```js
// index.js 是入口文件，云函数被调用时会执行该文件导出的 main 方法
// event 包含了调用端（小程序端）调用该函数时传过来的参数，同时还包含了可以通过 getWXContext 方法获取的用户登录态 `openId` 和小程序 `appId` 信息
const cloud = require('wx-server-sdk')
exports.main = async (event, context) => {
  let { userInfo, a, b} = event
  let { OPENID, APPID } = cloud.getWXContext() // 这里获取到的 openId 和 appId 是可信的
  let sum = a + b

  return {
    OPENID,
    APPID,
    sum
  }
}
```

云函数本地调试

```js
wx.cloud.callFunction({
  // 需调用的云函数名
  name: 'add',
  // 传给云函数的参数
  data: {
    a: 12,
    b: 19,
  },
  // 成功回调
  complete: console.log
})
// 当然 promise 方式也是支持的
wx.cloud.callFunction({
  name: 'add',
  data: {
    a: 12,
    b: 19
  }
}).then(console.log)
```
